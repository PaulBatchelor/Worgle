#+TITLE: Core
The section described here outlines core functionality for
worgmap. This involves anything related to querying tables
for SQLite data.
* Tangled Files
Core tanlges itself into a C and a header file, called
=core.c= and =core.h=, respectively.
#+NAME: core.h
#+BEGIN_SRC c :tangle core.h
#ifndef CORE_H
#define CORE_H
/* OSX is a real jerk */
#ifdef _SQLITE3_H_
#define SQLITE3_H
#endif
<<macros>>
<<typedefs>>
<<function_declarations>>
#endif
#+END_SRC
#+NAME: core_private.h
#+BEGIN_SRC c :tangle core_private.h
#ifndef CORE_PRIVATE_H
#define CORE_PRIVATE_H
<<structs>>
#endif
#+END_SRC
#+NAME: core.c
#+BEGIN_SRC c :tangle core.c
#include <sqlite3.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include "core.h"
#include "core_private.h"
<<constants>>
<<functions>>
#+END_SRC
* Error codes
To be proliferated throughout worgmap soon.
#+NAME: macros
#+BEGIN_SRC c
#define WMP_OK 1
#define WMP_NOT_OK 0
#+END_SRC
* wmp_core
** Struct
SQLite data is indirectly handled inside of a struct called
=wmp_core=. That's all it does for now, but I fully expect
things to change in the future.

#+NAME: typedefs
#+BEGIN_SRC c
typedef struct wmp_core wmp_core;
#+END_SRC

#+NAME: structs
#+BEGIN_SRC c
struct wmp_core {
    sqlite3 *db;
};
#+END_SRC
** DONE Opening the database
CLOSED: [2019-08-31 Sat 06:09]
The database handled is opened with the function
=wmp_core_open=.
#+NAME: function_declarations
#+BEGIN_SRC c
int wmp_core_open(wmp_core *core, const char *filename);
#+END_SRC
#+NAME: functions
#+BEGIN_SRC c
int wmp_core_open(wmp_core *core, const char *filename)
{
    sqlite3 *db;
    int rc;
    FILE *fp;

    fp = fopen(filename, "r");
    if (fp == NULL) {
        fprintf(stderr,
                "Database %s not found.\n",
                filename);
        return 0;
    }
    fclose(fp);

    core->db = NULL;
    rc = sqlite3_open(filename, &db);
    if (rc) {
        fprintf(stderr,
                "Could not open database: %s",
                sqlite3_errmsg(db));
        sqlite3_close(db);
        return 0;
    }

    core->db = db;
    return 1;
}
#+END_SRC
** DONE Closing the database
CLOSED: [2019-08-31 Sat 06:10]
The database handle is closed with the function
=wmp_core_close=.
#+NAME: function_declarations
#+BEGIN_SRC c
void wmp_core_close(wmp_core *core);
#+END_SRC
#+NAME: functions
#+BEGIN_SRC c
void wmp_core_close(wmp_core *core)
{
    sqlite3_close(core->db);
}
#+END_SRC
** DONE Getting SQLite data type
CLOSED: [2019-08-31 Sat 06:13]
Retrieved using the function =wmp_core_db=.

This will only be defined if the sqlite3 header
file is included before this header. Otherwise,
including sqlite3 would be a prereq for anything
wanting to include =core.h=.
#+NAME: function_declarations
#+BEGIN_SRC c
#ifdef SQLITE3_H
sqlite3 * wmp_core_db(wmp_core *core);
#endif
#+END_SRC
#+NAME: functions
#+BEGIN_SRC c
sqlite3 * wmp_core_db(wmp_core *core)
{
    return core->db;
}
#+END_SRC
** DONE Default Filename
CLOSED: [2019-08-31 Sat 06:21]
To make the CLI more terse, a default filename is used,
which can be configured through command line flags.
** Global Definition
The default filename is =a.db=.
#+NAME: constants
#+BEGIN_SRC c
const char *db_filename = "a.db";
#+END_SRC
** Setters/Getters
#+NAME: function_declarations
#+BEGIN_SRC c
const char * wmp_filename_get(void);
void wmp_filename_set(const char *filename);
#+END_SRC
#+NAME: functions
#+BEGIN_SRC c
const char * wmp_filename_get(void)
{
    return db_filename;
}

void wmp_filename_set(const char *filename)
{
    db_filename = filename;
}
#+END_SRC
* Resource
** Struct
A =wmp_resource= is a record from the resource table.
Any thing that is a thing has a record here. The only things
that a resource stores is the UUID and the type flag.
#+NAME: typedefs
#+BEGIN_SRC c
typedef struct wmp_resource wmp_resource;
#+END_SRC
#+NAME: structs
#+BEGIN_SRC c
struct wmp_resource {
    unsigned int id;
    int type;
    int prog;
};
#+END_SRC
#+NAME: function_declarations
#+BEGIN_SRC c
void wmp_resource_init(wmp_resource *r);
#+END_SRC
#+NAME: functions
#+BEGIN_SRC c
void wmp_resource_init(wmp_resource *r)
{
    r->id = 0;
    r->type = -1;
    r->prog = -1;
}
#+END_SRC
** Finding a Resource
The function =wmp_find_resource= will find a resource with
a particular UUID and place store the values in the
=wmp_resource= struct. If the return value is false (0),
then there was a problem finding the resource.

#+NAME: function_declarations
#+BEGIN_SRC c
int wmp_find_resource(wmp_core *c,
                      unsigned int uuid,
                      wmp_resource *r,
                      int prog);
#+END_SRC

No free function is needed here, since this struct does
not need to store any strings.

#+NAME: functions
#+BEGIN_SRC c
int wmp_find_resource(wmp_core *c,
                      unsigned int uuid,
                      wmp_resource *r,
                      int prog)
{
    sqlite3 *db;
    sqlite3_stmt *stmt;
    int type;
    int rc;

    db = wmp_core_db(c);

    sqlite3_prepare_v2(db,
                       "SELECT type FROM resources "
                       "WHERE id==?1 and "
                       "program == ?2",
                       -1,
                       &stmt,
                       NULL);
    sqlite3_bind_int(stmt, 1, uuid);
    sqlite3_bind_int(stmt, 2, prog);

    rc = sqlite3_step(stmt);

    if (rc == SQLITE_DONE) {
        sqlite3_finalize(stmt);
        return 0;
    }

    if (rc == SQLITE_ROW) {
        type = sqlite3_column_int(stmt, 0);

        r->id = uuid;
        r->type = type;
        r->prog = prog;
    } else {
        fprintf(stderr, "Error: %s\n", sqlite3_errmsg(db));
        sqlite3_finalize(stmt);
        return 0;
    }
    sqlite3_finalize(stmt);
    return 1;
}
#+END_SRC
** Resource Type to String
Returns a human readable string from the type.
#+NAME: function_declarations
#+BEGIN_SRC c
const char *wmp_resource_typestring(wmp_resource *r);
#+END_SRC
#+NAME: functions
#+BEGIN_SRC c
const char *wmp_resource_typestring(wmp_resource *r)
{
    switch(r->type) {
        case 0:
            return "File";
        case 1:
            return "Block";
        case 2:
            return "Segment";
    }
    return "Unknown";
}
#+END_SRC
** Find last ID of program
The last ID of a program can be reasonably assumed to be
the greatest ID of a program, this can be found using
the =MAX= argument.

#+NAME: function_declarations
#+BEGIN_SRC c
unsigned int wmp_resource_last(wmp_core *c, wmp_resource *r, int prog);
#+END_SRC

#+NAME: functions
#+BEGIN_SRC c
unsigned int wmp_resource_last(wmp_core *c, wmp_resource *r, int prog)
{
    sqlite3 *db;
    sqlite3_stmt *stmt;
    int rc;
    unsigned int last;

    db = wmp_core_db(c);

    last = 0;

    sqlite3_prepare_v2(db,
                       "SELECT MAX(id) from resources "
                       "where program == ?1;",
                       -1,
                       &stmt,
                       NULL);

    sqlite3_bind_int(stmt, 1, prog);

    rc = sqlite3_step(stmt);

    if (rc == SQLITE_DONE) {
        sqlite3_finalize(stmt);
        return 0;
    }

    if (rc == SQLITE_ROW) {
        last = sqlite3_column_int(stmt, 0);
    }

    if (r != NULL) {
        rc = wmp_find_resource(c, last, r, prog);
        if (!rc) last = 0;
    }

    sqlite3_finalize(stmt);

    return last;
}
#+END_SRC
* Segment
** Struct
A =wmp_segment= stores a segment of text from the segment
table.

#+NAME: typedefs
#+BEGIN_SRC c
typedef struct wmp_segment wmp_segment;
#+END_SRC

#+NAME: structs
#+BEGIN_SRC c
struct wmp_segment {
    unsigned int id;
    int type;
    char *str;
    int linum;
    char *filename;
    int nxtseg;
    int prog;
};
#+END_SRC

A =wmp_segment= can be queried by UUID using the function
=wmp_find_segment=. If the return value is false (0), then
there was a problem finding the entry.

The function =wmp_find_segment= allocates memory to store
the segment text as a C-string. Because of this, a segment
must be freed using the function =wmp_segment_free=.
** init
A segment is initialized with =wmp_segment_init=.
#+NAME: function_declarations
#+BEGIN_SRC c
void wmp_segment_init(wmp_segment *s);
#+END_SRC
#+NAME: functions
#+BEGIN_SRC c
void wmp_segment_init(wmp_segment *s)
{
    s->id = 0;
    s->type = -1;
    s->str = NULL;
    s->linum = 0;
    s->filename = NULL;
    s->nxtseg = -1;
    s->prog = -1;
}
#+END_SRC
** Free
#+NAME: function_declarations
#+BEGIN_SRC c
void wmp_segment_free(wmp_segment *s);
#+END_SRC
#+NAME: functions
#+BEGIN_SRC c
void wmp_segment_free(wmp_segment *s)
{
    free(s->str);
    free(s->filename);
}
#+END_SRC
** Find
#+NAME: function_declarations
#+BEGIN_SRC c
int wmp_find_segment(wmp_core *c,
                     unsigned int uuid,
                     wmp_segment *s,
                     int prog);
#+END_SRC
#+NAME: functions
#+BEGIN_SRC c
int wmp_find_segment(wmp_core *c,
                     unsigned int uuid,
                     wmp_segment *s,
                     int prog)
{
    sqlite3 *db;
    sqlite3_stmt *stmt;
    int rc;
    int nbytes;
    const char *str;
    const char *fname;

    db = wmp_core_db(c);

    sqlite3_prepare_v2(db,
                       "SELECT "
                         "type,"
                         "str,"
                         "linum,"
                         "filename,"
                         "next_segment, "
                         "program "
                       "FROM segments "
                       "WHERE(id==?1) AND "
                       "(program==?2) ",
                       -1,
                       &stmt,
                       NULL);
    sqlite3_bind_int(stmt, 1, uuid);
    sqlite3_bind_int(stmt, 2, prog);

    rc = sqlite3_step(stmt);

    if(rc == SQLITE_DONE) {
        sqlite3_finalize(stmt);
        return WMP_NOT_OK;
    }

    if(rc == SQLITE_ROW) {
        s->id = uuid;
        s->type = sqlite3_column_int(stmt, 0);

        nbytes = sqlite3_column_bytes(stmt, 1);
        s->str = calloc(1, nbytes + 1);
        str = (const char *)sqlite3_column_text(stmt, 1);
        strncpy(s->str, str, nbytes);

        s->linum = sqlite3_column_int(stmt, 2);

        nbytes = sqlite3_column_bytes(stmt, 3);
        s->filename = calloc(1, nbytes + 1);
        fname = (const char *)sqlite3_column_text(stmt, 3);
        strncpy(s->filename, fname, nbytes);

        s->nxtseg = sqlite3_column_int(stmt, 4);
        s->prog = sqlite3_column_int(stmt, 5);
    } else {
        fprintf(stderr, "Error: %s\n", sqlite3_errmsg(db));
        sqlite3_finalize(stmt);
        return WMP_NOT_OK;
    }
    sqlite3_finalize(stmt);
    return WMP_OK;
}
#+END_SRC
* Block
** struct
=wmp_block= stores a reference to a codeblock.
#+NAME: typedefs
#+BEGIN_SRC c
typedef struct wmp_block wmp_block;
#+END_SRC
#+NAME: structs
#+BEGIN_SRC c
struct wmp_block {
    int id;
    int head_segment;
    char *name;
    int prog;
    int nblocks;
    int nsegs;
};
#+END_SRC
** init
It is initialized using =wmp_block_init=.
#+NAME: function_declarations
#+BEGIN_SRC c
void wmp_block_init(wmp_block *b);
#+END_SRC
#+NAME: functions
#+BEGIN_SRC c
void wmp_block_init(wmp_block *b)
{
    b->id = -1;
    b->head_segment = -1;
    b->name = NULL;
    b->prog = -1;
    b->nblocks = -1;
    b->nsegs = -1;
}
#+END_SRC
** free
It is freed using =wmp_block_free=.
#+NAME: function_declarations
#+BEGIN_SRC c
void wmp_block_free(wmp_block *b);
#+END_SRC
#+NAME: functions
#+BEGIN_SRC c
void wmp_block_free(wmp_block *b)
{
    free(b->name);
}
#+END_SRC
** DONE find
CLOSED: [2019-08-31 Sat 09:55]
It is queried using =wmp_find_block=.
#+NAME: function_declarations
#+BEGIN_SRC c
int wmp_find_block(wmp_core *c,
                   unsigned int uuid,
                   wmp_block *b,
                   int prog);
#+END_SRC

#+NAME: functions
#+BEGIN_SRC c
int wmp_find_block(wmp_core *c,
                   unsigned int uuid,
                   wmp_block *b,
                   int prog)
{
    sqlite3 *db;
    sqlite3_stmt *stmt;
    int rc;
    int nbytes;
    const char *str;

    db = wmp_core_db(c);

    sqlite3_prepare_v2(db,
                       "SELECT "
                         "head_segment,"
                         "name, "
                         "program, nblocks, nsegs "
                       "FROM blocks "
                       "WHERE(id==?1) AND "
                       "(program==?2);",
                       -1,
                       &stmt,
                       NULL);
    sqlite3_bind_int(stmt, 1, uuid);
    sqlite3_bind_int(stmt, 2, prog);

    rc = sqlite3_step(stmt);

    if (rc == SQLITE_DONE) {
        sqlite3_finalize(stmt);
        return WMP_NOT_OK;
    }

    if (rc == SQLITE_ROW) {
        b->id = uuid;
        b->head_segment = sqlite3_column_int(stmt, 0);
        nbytes = sqlite3_column_bytes(stmt, 1);
        b->name = calloc(1, nbytes + 1);
        str = (const char *)sqlite3_column_text(stmt, 1);
        strncpy(b->name, str, nbytes);
        b->prog = sqlite3_column_int(stmt, 2);
        b->nblocks = sqlite3_column_int(stmt, 4);
        b->nsegs = sqlite3_column_int(stmt, 5);
    } else {
        fprintf(stderr, "Error: %s\n", sqlite3_errmsg(db));
        sqlite3_finalize(stmt);
        return WMP_NOT_OK;
    }
    sqlite3_finalize(stmt);
    return WMP_OK;
}
#+END_SRC
** DONE lookup
CLOSED: [2019-08-31 Sat 12:33]
A block can also be found by querying the name via the
function =wmp_lookup_block=.
#+NAME: function_declarations
#+BEGIN_SRC c
int wmp_lookup_block(wmp_core *c,
                     const char *name,
                     wmp_block *b,
                     int prog);
#+END_SRC
#+NAME: functions
#+BEGIN_SRC c
int wmp_lookup_block(wmp_core *c,
                     const char *name,
                     wmp_block *b,
                     int prog)
{
    sqlite3 *db;
    sqlite3_stmt *stmt;
    int rc;
    int nbytes;

    db = wmp_core_db(c);

    sqlite3_prepare_v2(db,
                       "SELECT "
                         "id,"
                         "head_segment, nblocks, nsegs "
                       "FROM blocks "
                       "WHERE(name==?1) AND "
                       "(program == ?2);",
                       -1,
                       &stmt,
                       NULL);
    sqlite3_bind_text(stmt, 1, name, strlen(name), NULL);
    sqlite3_bind_int(stmt, 2, prog);

    rc = sqlite3_step(stmt);

    if(rc == SQLITE_DONE) {
        sqlite3_finalize(stmt);
        return 0;
    }

    if(rc == SQLITE_ROW) {
        b->id = sqlite3_column_int(stmt, 0);
        b->head_segment = sqlite3_column_int(stmt, 1);
        nbytes = strlen(name);
        b->name = calloc(1, nbytes + 1);
        strncpy(b->name, name, nbytes);
        b->prog = prog;
        b->nblocks = sqlite3_column_int(stmt, 2);
        b->nsegs = sqlite3_column_int(stmt, 3);
    } else {
        fprintf(stderr, "Error: %s\n", sqlite3_errmsg(db));
        sqlite3_finalize(stmt);
        return 0;
    }
    sqlite3_finalize(stmt);
    return 1;
}
#+END_SRC
* File
** Struct
A =wmp_file= is a record containing the name of a file to
tangle to.
#+NAME: typedefs
#+BEGIN_SRC c
typedef struct wmp_file wmp_file;
#+END_SRC
#+NAME: structs
#+BEGIN_SRC c
struct wmp_file {
    unsigned int id;
    char *filename;
    int top;
    int next_file;
    int prog;
};
#+END_SRC
** init
It is initialized using =wmp_file_init=.
#+NAME: function_declarations
#+BEGIN_SRC c
void wmp_file_init(wmp_file *f);
#+END_SRC
#+NAME: functions
#+BEGIN_SRC c
void wmp_file_init(wmp_file *f)
{
    f->id = 0;
    f->filename = NULL;
    f->next_file = -1;
    f->prog = -1;
}
#+END_SRC
** Free
It is freed using =wmp_file_free=.
#+NAME: function_declarations
#+BEGIN_SRC c
void wmp_file_free(wmp_file *f);
#+END_SRC
#+NAME: functions
#+BEGIN_SRC c
void wmp_file_free(wmp_file *f)
{
    free(f->filename);
}
#+END_SRC
** Find
It is queried using =wmp_find_file=.
#+NAME: function_declarations
#+BEGIN_SRC c
int wmp_find_file(wmp_core *c,
                  unsigned int uuid,
                  wmp_file *f,
                  int prog);
#+END_SRC
#+NAME: functions
#+BEGIN_SRC c
int wmp_find_file(wmp_core *c,
                  unsigned int uuid,
                  wmp_file *f,
                  int prog)
{
    sqlite3 *db;
    sqlite3_stmt *stmt;
    int rc;
    int nbytes;
    const char *str;

    db = wmp_core_db(c);

    sqlite3_prepare_v2(db,
                       "SELECT "
                         "filename,"
                         "next_file, "
                         "top "
                       "FROM files "
                       "WHERE(id==?1) AND "
                       "(program == ?2);",
                       -1,
                       &stmt,
                       NULL);
    sqlite3_bind_int(stmt, 1, uuid);
    sqlite3_bind_int(stmt, 2, prog);

    rc = sqlite3_step(stmt);

    if(rc == SQLITE_DONE) {
        sqlite3_finalize(stmt);
        return 0;
    }

    if(rc == SQLITE_ROW) {
        f->id = uuid;
        nbytes = sqlite3_column_bytes(stmt, 0);
        f->filename = calloc(1, nbytes + 1);
        f->next_file = sqlite3_column_int(stmt, 1);
        str = (const char *)sqlite3_column_text(stmt, 0);
        strncpy(f->filename, str, nbytes);
        f->top = sqlite3_column_int(stmt, 2);
    } else {
        fprintf(stderr, "Error: %s\n", sqlite3_errmsg(db));
        sqlite3_finalize(stmt);
        return 0;
    }
    sqlite3_finalize(stmt);
    return 1;
}
#+END_SRC
** Lookup
A file can be queried by name directly via the function
=wmp_lookup_file=.

#+NAME: function_declarations
#+BEGIN_SRC c
int wmp_lookup_file(wmp_core *c,
                     const char *filename,
                     wmp_file *f);
#+END_SRC
#+NAME: functions
#+BEGIN_SRC c
int wmp_lookup_file(wmp_core *c,
                     const char *filename,
                     wmp_file *f)
{
    sqlite3 *db;
    sqlite3_stmt *stmt;
    int rc;
    int nbytes;

    db = wmp_core_db(c);

    sqlite3_prepare_v2(db,
                       "SELECT "
                         "id,"
                         "next_file, "
                         "top, "
                         "program "
                       "FROM files "
                       "WHERE(filename==?1);",
                       -1,
                       &stmt,
                       NULL);
    sqlite3_bind_text(stmt, 1,
                      filename, strlen(filename),
                      NULL);

    rc = sqlite3_step(stmt);

    if (rc == SQLITE_DONE) {
        sqlite3_finalize(stmt);
        return 0;
    }

    if (rc == SQLITE_ROW) {
        f->id = sqlite3_column_int(stmt, 0);
        f->next_file = sqlite3_column_int(stmt, 1);
        nbytes = strlen(filename);
        f->filename = calloc(1, nbytes + 1);
        strncpy(f->filename, filename, nbytes);
        f->top = sqlite3_column_int(stmt, 2);
        f->prog = sqlite3_column_int(stmt, 3);
    } else {
        fprintf(stderr, "Error: %s\n", sqlite3_errmsg(db));
        sqlite3_finalize(stmt);
        return 0;
    }
    sqlite3_finalize(stmt);
    return 1;
}
#+END_SRC
** Top File
Gets top file from the files column. Useful if you want to
iterate throught the file list.
#+NAME: function_declarations
#+BEGIN_SRC c
int wmp_file_top(wmp_core *c, wmp_file *f, int prog);
#+END_SRC
#+NAME: functions
#+BEGIN_SRC c
int wmp_file_top(wmp_core *c, wmp_file *f, int prog)
{
    sqlite3 *db;
    sqlite3_stmt *stmt;
    int rc;
    int nbytes;
    const char *filename;

    db = wmp_core_db(c);

    sqlite3_prepare_v2(db,
                       "SELECT "
                         "id,"
                         "filename,"
                         "next_file, "
                         "top "
                       "FROM files "
                       "WHERE (program == ?1) "
                       "LIMIT 1;",
                       -1,
                       &stmt,
                       NULL);
    sqlite3_bind_int(stmt, 1, prog);
    rc = sqlite3_step(stmt);

    if(rc == SQLITE_DONE) {
        sqlite3_finalize(stmt);
        return 0;
    }

    if(rc == SQLITE_ROW) {
        f->id = sqlite3_column_int(stmt, 0);
        f->next_file = sqlite3_column_int(stmt, 2);
        nbytes = sqlite3_column_bytes(stmt, 1);
        f->filename = calloc(1, nbytes + 1);
        filename = (const char *)sqlite3_column_text(stmt, 1);
        strncpy(f->filename, filename, nbytes);
        f->top = sqlite3_column_int(stmt, 2);
    } else {
        fprintf(stderr, "Error: %s\n", sqlite3_errmsg(db));
        sqlite3_finalize(stmt);
        return 0;
    }
    sqlite3_finalize(stmt);
    return 1;
}
#+END_SRC
* Block Ref
** Struct
Known as =wmp_blkref=.
#+NAME: typedefs
#+BEGIN_SRC c
typedef struct wmp_blkref wmp_blkref;
#+END_SRC
#+NAME: structs
#+BEGIN_SRC c
struct wmp_blkref {
    unsigned int id;
    int ref;
    int pos;
    char *section;
    char *filename;
    int linum;
    int next;
    int prog;
    int segoff;
    int prev_lastseg;
};
#+END_SRC
** init
#+NAME: function_declarations
#+BEGIN_SRC c
void wmp_blkref_init(wmp_blkref *br);
#+END_SRC
#+NAME: functions
#+BEGIN_SRC c
void wmp_blkref_init(wmp_blkref *br)
{
    br->id = -1;
    br->ref = -1;
    br->section = NULL;
    br->filename = NULL;
    br->linum = -1;
    br->next = -1;
    br->prog = -1;
    br->segoff = -1;
    br->prev_lastseg = -1;
    br->pos = -1;
}
#+END_SRC
** Free
It is freed using =wmp_blkref_free=.
#+NAME: function_declarations
#+BEGIN_SRC c
void wmp_blkref_free(wmp_blkref *br);
#+END_SRC

After freeing the strings, the blkref is re-initialized for
re-use.

#+NAME: functions
#+BEGIN_SRC c
void wmp_blkref_free(wmp_blkref *br)
{
    if (br->filename != NULL) free(br->filename);
    if (br->section != NULL) free(br->section);

    /* re-initialize */
    wmp_blkref_init(br);
}
#+END_SRC
** Find
Just get the blkref data, given an id and program number.
#+NAME: function_declarations
#+BEGIN_SRC c
int wmp_blkref_find(wmp_core *c,
                    unsigned int id,
                    wmp_blkref *br,
                    int prog);
#+END_SRC

#+NAME: functions
#+BEGIN_SRC c
int wmp_blkref_find(wmp_core *c,
                    unsigned int id,
                    wmp_blkref *br,
                    int prog)
{
    sqlite3 *db;
    int rc;
    sqlite3_stmt *stmt;

    rc = 0;

    db = wmp_core_db(c);

    sqlite3_prepare_v2(db,
                       "SELECT "
                         "id, "
                         "ref, "
                         "section, "
                         "filename, "
                         "linum, "
                         "next, "
                         "program, "
                         "segoff, "
                         "prev_lastseg, "
                         "pos "
                       "FROM blkref "
                       "WHERE(id== ?1) AND "
                       "(program == ?2);"
                       ,
                       -1,
                       &stmt,
                       NULL);
    sqlite3_bind_int(stmt, 1, id);
    sqlite3_bind_int(stmt, 2, prog);

    rc = sqlite3_step(stmt);

    if (rc == SQLITE_ROW) {
        int nbytes;
        const char *sec;
        const char *fname;
        br->id = sqlite3_column_int(stmt, 0);
        br->ref = sqlite3_column_int(stmt, 1);

        nbytes = sqlite3_column_bytes(stmt, 2);
        br->section = calloc(1, nbytes + 1);
        sec = (const char *)sqlite3_column_text(stmt, 2);
        strncpy(br->section, sec, nbytes);

        nbytes = sqlite3_column_bytes(stmt, 3);
        br->filename = calloc(1, nbytes + 1);
        fname = (const char *)sqlite3_column_text(stmt, 3);
        strncpy(br->filename, fname, nbytes);

        br->linum = sqlite3_column_int(stmt, 4);

        br->next = sqlite3_column_int(stmt, 5);

        br->prog = sqlite3_column_int(stmt, 6);

        br->segoff = sqlite3_column_int(stmt, 7);

        br->prev_lastseg = sqlite3_column_int(stmt, 8);

        br->pos = sqlite3_column_int(stmt, 9);

        rc = WMP_OK;
    } else {
        fprintf(stderr, "Error: %s\n", sqlite3_errmsg(db));
        rc = WMP_NOT_OK;
    }

    sqlite3_finalize(stmt);
    return rc;
}
#+END_SRC
** Lookup
This function is interesting because it is only possible to
do with a SQL query; Worgle has no way of doing this
internally in C.

Due to the SQL-yness of this operation, this functionality
needs to be broken up into 2 parts.

The first part sets up the SQLite query. This creats a
=sqlite3_stmt=.

#+NAME: function_declarations
#+BEGIN_SRC c
#ifdef SQLITE3_H
<<blkref_funcdefs>>
#endif
#+END_SRC

#+NAME: blkref_funcdefs
#+BEGIN_SRC c
int wmp_blkref_lookup_setup(wmp_core *core,
                            const char *name,
                            int prog,
                            sqlite3_stmt **pstmt);
#+END_SRC

#+NAME: functions
#+BEGIN_SRC c
int wmp_blkref_lookup_setup(wmp_core *core,
                            const char *name,
                            int prog,
                            sqlite3_stmt **pstmt)
{
    sqlite3 *db;
    int rc;
    wmp_block b;

    wmp_block_init(&b);
    rc = wmp_lookup_block(core, name, &b, prog);

    if (!rc) return rc;

    db = wmp_core_db(core);

    sqlite3_prepare_v2(db,
                       "SELECT "
                         "id, "
                         "ref, "
                         "section, "
                         "filename, "
                         "linum, "
                         "next, "
                         "program, "
                         "segoff, "
                         "prev_lastseg, "
                         "pos "
                       "FROM blkref "
                       "WHERE(program == ?1) AND "
                       "(ref == ?2);"
                       ,
                       -1,
                       pstmt,
                       NULL);
    sqlite3_bind_int(*pstmt, 1, prog);
    sqlite3_bind_int(*pstmt, 2, b.id);
    wmp_block_free(&b);

    return 1;
}
#+END_SRC

The second part steps through the query and gets called
until there are no more values to return.

#+NAME: blkref_funcdefs
#+BEGIN_SRC c
int wmp_blkref_lookup_step(wmp_core *core,
                           sqlite3_stmt *stmt,
                           wmp_blkref *br);
#+END_SRC

#+NAME: functions
#+BEGIN_SRC c
int wmp_blkref_lookup_step(wmp_core *core,
                           sqlite3_stmt *stmt,
                           wmp_blkref *br)
{
    int rc;

    rc = sqlite3_step(stmt);

    if (rc == SQLITE_DONE) {
        wmp_blkref_free(br);
        sqlite3_finalize(stmt);
        return 0;
    }

    if (rc == SQLITE_ROW) {
        int nbytes;
        const char *sec;
        const char *fname;

        /* clear/free the blkref */
        wmp_blkref_free(br);

        br->id = sqlite3_column_int(stmt, 0);
        br->ref = sqlite3_column_int(stmt, 1);

        nbytes = sqlite3_column_bytes(stmt, 2);
        br->section = calloc(1, nbytes + 1);
        sec = (const char *)sqlite3_column_text(stmt, 2);
        strncpy(br->section, sec, nbytes);

        nbytes = sqlite3_column_bytes(stmt, 3);
        br->filename = calloc(1, nbytes + 1);
        fname = (const char *)sqlite3_column_text(stmt, 3);
        strncpy(br->filename, fname, nbytes);

        br->linum = sqlite3_column_int(stmt, 4);

        br->next = sqlite3_column_int(stmt, 5);

        br->prog = sqlite3_column_int(stmt, 6);

        br->segoff = sqlite3_column_int(stmt, 7);

        br->prev_lastseg = sqlite3_column_int(stmt, 8);

        br->pos = sqlite3_column_int(stmt, 9);
    } else {
        sqlite3 *db;

        db = wmp_core_db(core);
        fprintf(stderr, "Error: %s\n", sqlite3_errmsg(db));
        sqlite3_finalize(stmt);
        return WMP_NOT_OK;
    }

    return WMP_OK;
}
#+END_SRC
** Blockref Neighbor lookup
Given a block reference, find the id another block reference
at local position =p=. If nothing pops up, an invalid id of
0 gets returned.

#+NAME: function_declarations
#+BEGIN_SRC c
unsigned int wmp_blkref_neighbor(wmp_core *c,
                                 wmp_blkref *br,
                                 int pos);
#+END_SRC

The SQLite query looks like this:

#+BEGIN_SRC sqlite
select id from blkref where ref=?1 and pos=?2 and program=?3;
#+END_SRC

Where ?1 =ref= is the block reference id, found in the
passed in blkref, and ?2 =pos= is the local position. The
=program= ?3 is .

#+NAME: functions
#+BEGIN_SRC c
unsigned int wmp_blkref_neighbor(wmp_core *c,
                                 wmp_blkref *br,
                                 int pos)
{
    sqlite3 *db;
    int rc;
    sqlite3_stmt *stmt;
    unsigned int id;

    db = wmp_core_db(c);

    id = 0;

    sqlite3_prepare_v2(db,
                       "SELECT id "
                       "FROM blkref "
                       "WHERE(ref == ?1) AND "
                       "(pos == ?2) AND "
                       "(program == ?3);"
                       ,
                       -1,
                       &stmt,
                       NULL);
    sqlite3_bind_int(stmt, 1, br->ref);
    sqlite3_bind_int(stmt, 2, pos);
    sqlite3_bind_int(stmt, 3, br->prog);

    rc = sqlite3_step(stmt);

    if (rc == SQLITE_ROW) {
        id = sqlite3_column_int(stmt, 0);
    }

    sqlite3_finalize(stmt);
    return id;
}
#+END_SRC
** TODO Code Block Regeneration
The function =wmp_blkref_codeblock= will reproduce a portion
of a code block, referred to as a =subblock=, given a block
reference. This will return the code in the subblock as an
array of segments.

Since the segment list is dynamically allocated, it must be
also freed explicitly with =wmp_blkref_codeblock_free=.

#+NAME: function_declarations
#+BEGIN_SRC c
int wmp_blkref_codeblock(wmp_core *c,
                         wmp_blkref *br,
                         wmp_segment **segs,
                         int *nsegs);
void wmp_blkref_codeblock_free(wmp_core *c,
                               wmp_segment **segs,
                               int nsegs);
#+END_SRC

#+NAME: functions
#+BEGIN_SRC c
int wmp_blkref_codeblock(wmp_core *c,
                         wmp_blkref *br,
                         wmp_segment **segs,
                         int *nsegs)
{
    wmp_blkref next_br;
    unsigned int next_br_id;
    int rc;
    int len;
    wmp_segment *list;
    wmp_segment head;
    wmp_segment prevseg;
    wmp_block blk;
    int ok;
    int i;
    wmp_segment seg;

    ok = WMP_OK;
    len = 0;
    rc = -1;
    next_br_id = 0;
    list = NULL;

    wmp_blkref_init(&next_br);
    wmp_segment_init(&head);
    wmp_segment_init(&seg);
    wmp_segment_init(&prevseg);
    wmp_block_init(&blk);

    <<retrieve_next_block_reference>>
    <<retrieve_block_from_reference>>
    <<calculate_number_of_segments>>
    <<allocate_segment_list>>
    <<obtain_first_segment>>
    <<populate_segment_list>>

    (*nsegs) = len;
    *segs = list;


    cleanup:
    wmp_blkref_free(&next_br);
    wmp_block_free(&blk);
    wmp_segment_free(&prevseg);
    /* do not free head or seg , will be freed later */
    return ok;
}
#+END_SRC

From the block reference, retrieve the next block reference
(if it exists).
This will be needed later on. This can be retrieved using
the =pos= value in the block reference schema and the magic
of SQLite. =pos + 1= will get the next block reference.


#+NAME: retrieve_next_block_reference
#+BEGIN_SRC c
next_br_id = wmp_blkref_neighbor(c, br, br->pos + 1);
if (next_br_id > 0) {
    rc = wmp_blkref_find(c, next_br_id, &next_br, br->prog);
    if (rc != WMP_OK) {
        wmp_blkref_free(&next_br);
        ok = WMP_NOT_OK;
        goto cleanup;
    }
}
#+END_SRC

Retrieve the block and make sure it exists. This may be in
certain edge cases.

#+NAME: retrieve_block_from_reference
#+BEGIN_SRC c
rc = wmp_find_block(c, br->ref, &blk, br->prog);
if (rc != WMP_OK) {
    ok = WMP_NOT_OK;
    goto cleanup;
}
#+END_SRC

The number of segments in the subblock is calculated from
=segoff=, or the segment offset. The segment offset stores
the starting segment position relative to the block.
Subtracting =segoff= of the *next* subblock will get the size.
If there is no next reference, the
offset can be subtracted from the total number of segments
in the top-level block.

#+NAME: calculate_number_of_segments
#+BEGIN_SRC c
if (next_br_id > 0) {
    len = next_br.segoff - br->segoff;
} else {
    len = blk.nblocks - br->segoff;
}
#+END_SRC

The output segment list is then allocated with this value.

#+NAME: allocate_segment_list
#+BEGIN_SRC c
if (len > 0) {
    list = malloc(sizeof(wmp_segment) * len);
}
#+END_SRC

The first segment is obtained from =prev_lastseg=. It holds
the id of the last segment of the previous block reference.
Getting the =next= id from this segment will get the first
segment of the current subblock.

If no =prev_lastseg= is found, use the segment found
in the top-block.

#+NAME: obtain_first_segment
#+BEGIN_SRC c
if (br->prev_lastseg > 0) {
    rc = wmp_find_segment(c, br->prev_lastseg, &prevseg, br->prog);

    if (rc != WMP_OK) {
        ok = WMP_NOT_OK;
        goto cleanup;
    }

    rc = wmp_find_segment(c, prevseg.nxtseg, &head, br->prog);

    if (rc != WMP_OK) {
        ok = WMP_NOT_OK;
        goto cleanup;
    }
} else {
    rc = wmp_find_segment(c, blk.head_segment, &head, br->prog);
    if (rc != WMP_OK) {
        ok = WMP_NOT_OK;
        goto cleanup;
    }
}
#+END_SRC

After the first segment and total number of segments is
found, the rest of the procedure works like a linked list
operation, with each segment entry has a ID value pointing
to the next segment. The contents of each segment get copied
to their respective position in the segment list.

#+NAME: populate_segment_list
#+BEGIN_SRC c
list[0] = head;
seg = head;
for (i = 1; i < len; i++) {
    unsigned int nxt;
    nxt = seg.nxtseg;
    wmp_segment_init(&seg);
    rc = wmp_find_segment(c, nxt, &seg, br->prog);
    if (rc != WMP_OK) {
        ok = WMP_NOT_OK;
        len = i;
        goto cleanup;
    }
    list[i] = seg;
}
#+END_SRC

#+NAME: functions
#+BEGIN_SRC c
void wmp_blkref_codeblock_free(wmp_core *c,
                               wmp_segment **segs,
                               int nsegs)
{
    int i;
    wmp_segment *lst;

    lst = *segs;

    for (i = 0; i < nsegs; i++) {
        wmp_segment_free(&lst[i]);
    }

    free(lst);
}
#+END_SRC
* Block Search
Under the hood, this performs a SQL query in the blocks
table for any block matching a keyword, and returns the
a blocks that match it.

It's a two step function: setup and step. The last step
will automatically clean.

#+NAME: function_declarations
#+BEGIN_SRC c
#ifdef SQLITE3_H
<<blksearch_funcdefs>>
#endif
#+END_SRC
** Setup
#+NAME: blksearch_funcdefs
#+BEGIN_SRC c
int wmp_blksearch_setup(wmp_core *core,
                        const char *name,
                        sqlite3_stmt **pstmt);
#+END_SRC

#+NAME: functions
#+BEGIN_SRC c
int wmp_blksearch_setup(wmp_core *core,
                        const char *name,
                        sqlite3_stmt **pstmt)
{
    sqlite3 *db;

    db = wmp_core_db(core);

    sqlite3_prepare_v2(db,
                       "SELECT "
                         "id, "
                         "head_segment, "
                         "name, "
                         "program "
                       "FROM blocks "
                       "WHERE name LIKE ?1;"
                       ,
                       -1,
                       pstmt,
                       NULL);

    sqlite3_bind_text(*pstmt, 1, name, strlen(name), NULL);
    return 1;
}
#+END_SRC

#+NAME: blksearch_funcdefs
#+BEGIN_SRC c
int wmp_blksearch_step(wmp_core *core,
                       sqlite3_stmt *stmt,
                       wmp_block *blk);
#+END_SRC

#+NAME: functions
#+BEGIN_SRC c
int wmp_blksearch_step(wmp_core *core,
                       sqlite3_stmt *stmt,
                       wmp_block *blk)
{
    int rc;

    rc = sqlite3_step(stmt);

    if (rc == SQLITE_DONE) {
        wmp_block_free(blk);
        sqlite3_finalize(stmt);
        return 0;
    }

    if (rc == SQLITE_ROW) {
        int nbytes;
        const char *name;
        wmp_block_free(blk);

        blk->id = sqlite3_column_int(stmt, 0);

        blk->head_segment = sqlite3_column_int(stmt, 1);

        nbytes = sqlite3_column_bytes(stmt, 2);
        blk->name = calloc(1, nbytes + 1);
        name = (const char *)sqlite3_column_text(stmt, 2);
        strncpy(blk->name, name, nbytes);

        blk->prog = sqlite3_column_int(stmt, 3);
    } else {
        sqlite3 *db;

        db = wmp_core_db(core);
        fprintf(stderr, "Error: %s\n", sqlite3_errmsg(db));
        sqlite3_finalize(stmt);
        return 0;
    }

    return 1;
}
#+END_SRC
* Header
Gets header information.
** struct
#+NAME: typedefs
#+BEGIN_SRC c
typedef struct wmp_header wmp_header;
#+END_SRC
#+NAME: structs
#+BEGIN_SRC c
struct wmp_header {
    int prog;
    int id;
    char *section;
    int level;
    char *name;
    char *filename;
    int linum;
    int next;
};
#+END_SRC
** init
#+NAME: function_declarations
#+BEGIN_SRC c
void wmp_header_init(wmp_header *h);
#+END_SRC
#+NAME: functions
#+BEGIN_SRC c
void wmp_header_init(wmp_header *h)
{
    h->prog = -1;
    h->id = -1;
    h->section = NULL;
    h->level = -1;
    h->name = NULL;
    h->filename = NULL;
    h->linum = -1;
    h->next = -1;
}
#+END_SRC
** free
#+NAME: function_declarations
#+BEGIN_SRC c
void wmp_header_free(wmp_header *h);
#+END_SRC
#+NAME: functions
#+BEGIN_SRC c
void wmp_header_free(wmp_header *h)
{
    if (h->section != NULL) {
        free(h->section);
        h->section = NULL;
    }

    if (h->name != NULL) {
        free(h->name);
        h->name = NULL;
    }

    if (h->filename != NULL) {
        free(h->filename);
        h->filename = NULL;
    }
}
#+END_SRC
** find
#+NAME: function_declarations
#+BEGIN_SRC c
int wmp_header_find(wmp_core *c,
                    unsigned int uuid,
                    wmp_header *h,
                    int prog);
#+END_SRC

#+NAME: functions
#+BEGIN_SRC c
int wmp_header_find(wmp_core *c,
                    unsigned int uuid,
                    wmp_header *h,
                    int prog)
{
    sqlite3 *db;
    sqlite3_stmt *stmt;
    int rc;

    db = wmp_core_db(c);

    sqlite3_prepare_v2(db,
                       "SELECT "
                         "program, "
                         "id, "
                         "section, "
                         "level, "
                         "name , "
                         "filename , "
                         "linum , "
                         "next "
                       "FROM headers "
                       "WHERE(id==?1) AND "
                       "(program==?2);",
                       -1,
                       &stmt,
                       NULL);
    sqlite3_bind_int(stmt, 1, uuid);
    sqlite3_bind_int(stmt, 2, prog);

    rc = sqlite3_step(stmt);

    if (rc == SQLITE_DONE) {
        sqlite3_finalize(stmt);
        return 0;
    }

    if (rc == SQLITE_ROW) {
        h->prog = sqlite3_column_int(stmt, 0);
        h->id = sqlite3_column_int(stmt, 1);

        {
            int nbytes;
            const char *str;
            nbytes = sqlite3_column_bytes(stmt, 2);
            h->section = calloc(1, nbytes + 1);
            str = (const char *)sqlite3_column_text(stmt, 2);
            strncpy(h->section, str, nbytes);
        }

        h->level = sqlite3_column_int(stmt, 3);

        {
            int nbytes;
            const char *str;
            nbytes = sqlite3_column_bytes(stmt, 4);
            h->name = calloc(1, nbytes + 1);
            str = (const char *)sqlite3_column_text(stmt, 4);
            strncpy(h->name, str, nbytes);
        }

        {
            int nbytes;
            const char *str;
            nbytes = sqlite3_column_bytes(stmt, 5);
            h->filename = calloc(1, nbytes + 1);
            str = (const char *)sqlite3_column_text(stmt, 5);
            strncpy(h->filename, str, nbytes);
        }

        h->linum = sqlite3_column_int(stmt, 6);
        h->next = sqlite3_column_int(stmt, 7);
    } else {
        fprintf(stderr, "Error: %s\n", sqlite3_errmsg(db));
        sqlite3_finalize(stmt);
        return 0;
    }
    sqlite3_finalize(stmt);
    return 1;
}
#+END_SRC
** get top header
Finds the topmost header in a program. This is assumed
to be header chunk smallest ID.

This can be done with the following SQL query:

#+BEGIN_SRC sqlite
SELECT MIN(id) from headers where program == prog;
#+END_SRC

Where =prog= is the program id.

From there =wmp_header_find= can be called as usual.

#+NAME: function_declarations
#+BEGIN_SRC c
unsigned int wmp_header_top(wmp_core *c, wmp_header *h, int prog);
#+END_SRC

#+NAME: functions
#+BEGIN_SRC c
unsigned int wmp_header_top(wmp_core *c, wmp_header *h, int prog)
{
    sqlite3 *db;
    sqlite3_stmt *stmt;
    int rc;
    int top;

    db = wmp_core_db(c);

    top = 0;

    sqlite3_prepare_v2(db,
                       "SELECT MIN(id) from headers "
                       "where program == ?1;",
                       -1,
                       &stmt,
                       NULL);

    sqlite3_bind_int(stmt, 1, prog);

    rc = sqlite3_step(stmt);

    if (rc == SQLITE_DONE) {
        sqlite3_finalize(stmt);
        return 0;
    }

    if (rc == SQLITE_ROW) {
        top = sqlite3_column_int(stmt, 0);
    }

    sqlite3_finalize(stmt);

    if (h != NULL) {
        rc = wmp_header_find(c, top, h, prog);
        if (!rc) top = 0;
    }

    return top;
}
#+END_SRC
* Content
Gets content information.
** struct
#+NAME: typedefs
#+BEGIN_SRC c
typedef struct wmp_content wmp_content;
#+END_SRC
#+NAME: structs
#+BEGIN_SRC c
struct wmp_content {
    int prog;
    int id;
    char *section;
    char *filename;
    int linum;
    char *content;
    int next;
};
#+END_SRC
** init
#+NAME: function_declarations
#+BEGIN_SRC c
void wmp_content_init(wmp_content *c);
#+END_SRC
#+NAME: functions
#+BEGIN_SRC c
void wmp_content_init(wmp_content *c)
{
    c->prog = -1;
    c->id = -1;
    c->section = NULL;
    c->filename = NULL;
    c->linum = -1;
    c->content = NULL;
    c->next = -1;
}
#+END_SRC
** free
#+NAME: function_declarations
#+BEGIN_SRC c
void wmp_content_free(wmp_content *c);
#+END_SRC
#+NAME: functions
#+BEGIN_SRC c
void wmp_content_free(wmp_content *c)
{
    if (c->section != NULL) {
        free(c->section);
        c->section = NULL;
    }

    if (c->content != NULL) {
        free(c->content);
        c->content = NULL;
    }

    if (c->filename != NULL) {
        free(c->filename);
        c->filename = NULL;
    }
}
#+END_SRC
** find
#+NAME: function_declarations
#+BEGIN_SRC c
int wmp_content_find(wmp_core *c,
                     unsigned int uuid,
                     wmp_content *cnt,
                     int prog);
#+END_SRC

#+NAME: functions
#+BEGIN_SRC c
int wmp_content_find(wmp_core *c,
                     unsigned int uuid,
                     wmp_content *cnt,
                     int prog)
{
    sqlite3 *db;
    sqlite3_stmt *stmt;
    int rc;

    db = wmp_core_db(c);

    sqlite3_prepare_v2(db,
                       "SELECT "
                         "program, "
                         "id, "
                         "section, "
                         "filename , "
                         "linum , "
                         "content , "
                         "next "
                       "FROM content "
                       "WHERE(id==?1) AND "
                       "(program==?2);",
                       -1,
                       &stmt,
                       NULL);
    sqlite3_bind_int(stmt, 1, uuid);
    sqlite3_bind_int(stmt, 2, prog);

    rc = sqlite3_step(stmt);

    if (rc == SQLITE_DONE) {
        sqlite3_finalize(stmt);
        return 0;
    }

    if (rc == SQLITE_ROW) {
        cnt->prog = sqlite3_column_int(stmt, 0);
        cnt->id = sqlite3_column_int(stmt, 1);

        {
            int nbytes;
            const char *str;
            nbytes = sqlite3_column_bytes(stmt, 2);
            cnt->section = calloc(1, nbytes + 1);
            str = (const char *)sqlite3_column_text(stmt, 2);
            strncpy(cnt->section , str, nbytes);
        }

        {
            int nbytes;
            const char *str;
            nbytes = sqlite3_column_bytes(stmt, 3);
            cnt->filename = calloc(1, nbytes + 1);
            str = (const char *)sqlite3_column_text(stmt, 3);
            strncpy(cnt->filename, str, nbytes);
        }

        cnt->linum = sqlite3_column_int(stmt, 4);


        {
            int nbytes;
            const char *str;
            nbytes = sqlite3_column_bytes(stmt, 5);
            cnt->content = calloc(1, nbytes + 1);
            str = (const char *)sqlite3_column_text(stmt, 5);
            strncpy(cnt->content, str, nbytes);
        }

        cnt->next = sqlite3_column_int(stmt, 6);
    } else {
        fprintf(stderr, "Error: %s\n", sqlite3_errmsg(db));
        sqlite3_finalize(stmt);
        return 0;
    }
    sqlite3_finalize(stmt);
    return 1;
}
#+END_SRC
