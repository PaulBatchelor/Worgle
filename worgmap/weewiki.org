#+TITLE: WeeWiki
* Brain Storming
A work in progress idea...

The gist of this is to take a worgle program and export it
to a weewiki. From there, the weewiki can export the content
to HTML. Supplementary pages can also be added and linked.

My core thinking is to be able to export every major header
to it's own page. It will have the name format =wm_PROG_ID=,
where =PROG= is the program number, and =ID= is the resource
ID.

Every program generates a table of contents. It has the name
=wm_PROG_toc= where =PROG= is the program id.

Worgmap will write stuff to a file that is supplied. It
could be the worgmap db, but not necessarily.

In addition to appending stuff to the "wiki" table, a
reference table called =wm_ref= will be created, which links
worgmap page names to resource + program ids. Even though
this is information could be parsed in the page name, this
is a bit cleaner.

In order for this to work, worgmap must be able to
dynamically recreate org code, given a section (or resource
id of a section). This functionality will be implemented in
worgmap core.

Generating an org file is a a piecemeal operation. It is
created by stringing together a bunch headers, content, and
codeblocks to a string.

When worgle generates the database, it recreates the headers
and subheaders to include their section number.

Given a block reference, a code sub block can be printed.
Eventually, all references will have links to a special
generated codeblock page.
* Tangled Files
#+NAME: weewiki.c
#+BEGIN_SRC c :tangle weewiki.c
#include <stdio.h>
#include <string.h>
#include <sqlite3.h>
#include <stdlib.h>
#include "core.h"
#include "core_private.h"
<<functions>>
#+END_SRC
* Top Level Function
#+NAME: functions
#+BEGIN_SRC c
int p_weewiki(int argc, char *argv[])
{
    fprintf(stderr, "To be implemented later.\n");

    if (argc < 4) {
        fprintf(stderr, "Usage: %s program db\n", argv[0]);
        return 1;
    }

    <<open_the_db>>
    <<page_generation>>
    <<close_the_db>>
    return 0;
}
#+END_SRC
* Opening/Closing the database
If no filename is provided, the weewiki database is used.
Otherwise, a new SQLite database is opened.

#+NAME: open_the_db
#+BEGIN_SRC c

#+END_SRC

At the end, this SQLite database is closed. If it's the same
as the database (the same pointer), this does not happen.

#+NAME: close_the_db
#+BEGIN_SRC c

#+END_SRC
* Clearing + reset the weewiki tables
** Wiki
Create this table if it doesn't already exist.

Remove all rows with the prefix =wm_=.
** wm_ref
This links wiki names with program and resource ideas.
Create the table if doesn't exist, and clear any
pre-existing rows.
* Generation
#+NAME: page_generation
#+BEGIN_SRC c
<<find_first_id>>
<<iterate_through_components>>
#+END_SRC

Every major section in a program is written to a separate
file.

A program in this context is considered to be a collection
of top-level headers. If there are no level 1 headers, no
pages are created. Any text that occurs before the first
header will be skipped.

The first header in the program needs to be found. This is
the header with the smallest reference ID.

#+NAME: find_first_id
#+BEGIN_SRC c

#+END_SRC

Org code gets rendered by iterating through headers,
content, and block references.

#+NAME: iterate_through_components
#+BEGIN_SRC c
<<get_type>>
<<handle_component>>
<<get_next>>
<<create_page>>
#+END_SRC

These components are
connected together as a linked list. Every one of these
items has a "next" value, containing the reference ID.

#+NAME: get_next
#+BEGIN_SRC c

#+END_SRC

The type of the reference ID is determined, and then the
information is extracted from the right table.

#+NAME: get_type
#+BEGIN_SRC c

#+END_SRC

#+NAME: handle_component
#+BEGIN_SRC c
<<append_content>>
<<append_header>>
<<append_block>>
#+END_SRC

Components get appended onto the end of a string as org
code.

For content, it's a matter of appending the text
as-is. This is the most straightforward.

#+NAME: append_content
#+BEGIN_SRC c

#+END_SRC

Headers require some work. First, the header level is
applied (the number of stars). Following that, the
dynamically section number. Finally, the actual name itself
appended.

#+NAME: append_header
#+BEGIN_SRC c
<<check_for_new_section>>
#+END_SRC

Markers are referenced using inline janet function called
=marker=. This creates an id reference that jump links can
use.

A header marker generated with the format
=wm_PROG_ID= where =PROG= is the program number, and
=ID= is the reference id.

Generating code blocks is where things start to get
interesting. A code block first pops up as a block
reference, and is used to make a marker with the name
=wm_PROG_ID=. From the block reference, the code block
itself can be extracted. The subblock can then be recreated
using the =pos=, =ref=, =prev_lastseg=, and =segoff=
values.

A code subblock is a chain of segments. that gets written
inside of a subblock. Segments are either piece of text,
or block references. Block references will eventually turn
into hyperlinks that go to a block page.

#+NAME: append_block
#+BEGIN_SRC c

#+END_SRC

Items are appended onto an org string until the next major
org header is found.

#+NAME: check_for_new_section
#+BEGIN_SRC c

#+END_SRC

#+NAME: create_page
#+BEGIN_SRC c

#+END_SRC
* Meta Page Generation
Metapages are pages that are dynamically generated using
SQL queries. These include a table of contents, a block
tree, and block pages.

A table of contents page generates a list of links for all
the sections and subsections. Each section links to a page,
and every subsection links to it's major section page with
a jump link.

Indentation will easier visibility, however the HTML will
be abstracted away into inline janet functions, should this
code ever want to be exported to a non-HTML format someday.
This is TBD.

A block tree is like a table of contents, but it outlines
the code block hierachy in the program structure. Each of
these blocks link to block pages.

Block pages give meta information about each block and where
they are located. This will include links to every subblock.
* Inserting Pages
Inserting a page involves two INSERT statements: one for
the main =wiki= table, and other for the =wm_ref= table.

Three parameters are needed to insert a page: the page name,
the content, and the id.

The =wiki= table uses both the content and and the name. The
=wm_ref= table uses the id and the name.
