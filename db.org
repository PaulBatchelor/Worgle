#+TITLE: Worgle Database
* Worgle Database (WIP)
This section outlines the portion of Worgle which handles database
export. At the time of writing, this feature does not exist yet.
The main idea behind this is to be able to take a program Org, and
export all the metadata into a SQLite database. In the future, other
programs will be written to query the generated database and dynamically
display portions of the program in interesting ways.

Instead of using the SQLite API to generate the database directly, the Worgle
database interface will write SQL INSERT statements to be read by the sqlite3
command line interface.
** Worgle Database Top
*** Top-level files
The worgle database interface generates a single C and header file.

# functions and function_declarations correspond to the main worgle.org file

#+NAME: db-top
#+BEGIN_SRC c :tangle db.c
#include <stdio.h>
#include "worgle.h"
#include "db.h"
<<macros>>
<<functions>>
#+END_SRC
#+NAME: db-header
#+BEGIN_SRC c :tangle db.h
#ifndef WORGLE_DB_H
#define WORGLE_DB_H
<<function_declarations>>
#endif
#+END_SRC
*** Top-level function
The SQLite database generation is done with the function =worgle_db_generate=.
It will write SQLite commands to a file handle =fp=.
#+NAME: function_declarations
#+BEGIN_SRC c
void worgle_db_generate(worgle_d *worg, FILE *fp);
#+END_SRC

#+NAME: functions
#+BEGIN_SRC c
void worgle_db_generate(worgle_d *worg, FILE *fp)
{
    <<schemas>>
}
#+END_SRC
** SQLite Schemas
The following section describes the SQLite schemas for all the tables
needed by Worgle.
*** Segment Schema
The segment schema contains the following items:

- the UUID
- the type (stored as integer)
- the line number
- the file (filename, not UUID) that it belongs to
- the UUID of the next segment

The types for segments are defined in an ENUM.

#+NAME: macros
#+BEGIN_SRC c
enum {
    SEGMENT_STRING,
    SEGMENT_REFERENCE
};
#+END_SRC

#+NAME: schemas
#+BEGIN_SRC c
fprintf(fp, "CREATE TABLE segments(\n");
fprintf(fp, "id INTEGER PRIMARY KEY,\n");
fprintf(fp, "type INTEGER,\n");
fprintf(fp, "linum INTEGER,\n");
fprintf(fp, "filename TEXT,\n");
fprintf(fp, "next_segment INTEGER\n");
fprintf(fp, ");");
#+END_SRC
*** Block Schema
The block schema contains the following items:

- the UUID
- the UUID of the segment head
- the name of the block
- the UUID of the next block

#+NAME: schemas
#+BEGIN_SRC c
fprintf(fp, "CREATE TABLE block(\n");
fprintf(fp, "id INTEGER PRIMARY KEY,\n");
fprintf(fp, "head_segment INTEGER,\n");
fprintf(fp, "name TEXT,\n");
fprintf(fp, "next_block INTEGER\n");
fprintf(fp, ");");
#+END_SRC
*** File Schema
A file name table contains the following:

- UUID
- filename
- the top-level block
- the UUID for the next file (0 if there is no next file)

#+NAME: schemas
#+BEGIN_SRC c
fprintf(fp, "CREATE TABLE file(\n");
fprintf(fp, "id INTEGER PRIMARY KEY,\n");
fprintf(fp, "filename TEXT,\n");
fprintf(fp, "type INTEGER,\n");
fprintf(fp, "next_file INTEGER\n");
fprintf(fp, ");");
#+END_SRC
*** UUID Schema
Every single UUID is logged into a single table. This table has every single
UUID and their type.

- UUID
- type (as an integer)

The integer-based types are defined as enums below:

#+NAME: macros
#+BEGIN_SRC c
enum {
    RES_FILE,
    RES_BLOCK,
    RES_SEGMENT
};
#+END_SRC

#+NAME: schemas
#+BEGIN_SRC c
fprintf(fp, "CREATE TABLE resources(\n");
fprintf(fp, "id INTEGER PRIMARY KEY,\n");
fprintf(fp, "type INTEGER\n");
fprintf(fp, ");");
#+END_SRC
