* Notice

This is a work in progress. There's not a whole lot here yet.

Don't run this yet!
* What is Worgle?

Hello, fellow human. I'm glad you could stop by.

This is a document written
in Org markup, talking about a thing I'm building called Worgle. The name
*Worgle* is derived from what it is: a Worg Tangler. =Worg= is the name of this
project. It too gets its name from what it is: a WEB + Org project.
Org is the very decent markup language from org-mode.
WEB is
the name of the first literate programming tool ever created by Donald Knuth.
In literate programming,
one writes language and code together in a markup language, which can
then be parsed two ways. The *weaver* parses the markup to produce a
human readable document, usually a (La)TeX or HTML file. The *tangler*
parses the markup and produces computer code that can be read by a computer
to run or compile the program.

In other words, Worgle is a literate programming tangler used to convert
org-like markup into (primarily) code.

Worgle itself is a literate program, so what tangles the worgle code? Orgle
does! Orgle is a program written in C without literate programming. It is
designed to be just enough of a program to bootstrap Worgle. Worgle will
then be used as the tangler for the rest of Worg.

Worgle will initially start out as a literate program of Orgle. In fact,
this document will initially start out as an outline for the Orgle program.
The Orgle program will be considered done when it is able to produce a similar
program by parsing this Worgle document. After that is done, more work will
be put into Worgle to make it more suitable for managing larger projects
written in C.

Following me so far? No? Yes? Great, let's get started.
* Top-level files

Like Orgle, Worgle is self contained inside of a single C file.
For the time being, this is suitable enough. The current scope of Worgle is
to be a self-contained standalone CLI application.

#+NAME: worgle-top
#+BEGIN_SRC c :tangle worgle.c

#include <stdio.h>
#include <stdlib.h>
#include <string.h>

<<structs>>

int main(int argc, char *argv[])
{
    printf("Sorry. No Worgling yet.\n");
    <<loading>>
    <<parsing>>
    <<generation>>
    return 0;
}

#+END_SRC
* An Outline of What Worgle does

This aims to show a broad overview of how Orgle (and Worgle) will work
essentially. Orgle is a bootstrap program written in C, used to generate
C code for Worgle (this program here). At the highest level, the two
programs share the same basic program structure.
** Load file into memory

The first thing the program will do is load the file.

While most parsers tend to parse things on a line by line basis via
a file stream, this parser will load the entire file into memory. This
is done due to the textual nature of the program. It is much easier to
simply allocate everything in one big block and reference chunks, then to
allocate smaller chunks as you go.

#+NAME:loading
#+BEGIN_SRC c

#+END_SRC
** Parsing

The second phase of the program is the parsing stage.

The parsing stage will parse files line-by-line. The program will find a line
by skimming through the block up to a line break character, then pass
that off to be parsed. Line by line, the parser will read the program and
produce a structure of the tangled code in memory.

#+NAME:parsing
#+BEGIN_SRC c

#+END_SRC
*** Reading a line at a time

Despite being loaded into memory, the program still reads in code one line
at a time. The parsing relies on new line feeds to denote the beginnings
and endings of sections and code references.

A special readline function has been written based on =getline= that reads
lines of text from an allocated block of text.
*** Parsing Modes

The parser is implemented as a relatively simple state machine, whose behavior
shifts between parsing org-mode markup (=MODE_ORG=), and code blocks
(=MODE_BEGINCODE= and =MODE_CODE=).
The state machine makes a distinction between the start of a new code
block (=MODE_BEGINCODE=), which provides information like the name of
the code block and optionally the name of the file to tangle to, and
the code block itself (=MODE_CODE=).
**** MODE_ORG

***** Extracting information from #+NAME

***** Beginning a new block

**** MODE_BEGINCODE

***** Extracting information from #+BEGIN_SRC

***** Setting up code for a new read

**** MODE_CODE

***** Checking for #+END_SRC

***** Checking for references
** Generation

The last phase of the program is code generation.

A parsed file generates a structure of how the code will look. The generation
stage involves iterating through the structure and producing the code.

Due to the hierarchical nature of the data structures,
the generation stage is surprisingly elegant with a single expanding entry
point.

At the very top, generation
consists of writing all the files in the filelist. Each file will then go
and write the top-most block associated with that file. A block will then
write the segment list it has embedded inside of it. A segment will either
write a string literal to disk, or a recursively expand block reference.

#+NAME:generation
#+BEGIN_SRC c

#+END_SRC

* Core Data Structures

The Worgle/Orgle program is very much a data-structure driven program.
Understanding the hierarchy of data here will provide a clear picture for
how the tangling works.

#+NAME: structs
#+BEGIN_SRC c
<<worgle_string>>
<<worgle_segment>>
<<worgle_block>>
<<worgle_blocklist>>
<<worgle_hashmap>>
#+END_SRC

** Top Level Struct

All Worgle operations are contained in a top-level struct called =worgle_d=.
For the most part, this struct aims to be dynamically populated inside of
[[An Outline of What Worgle does]].
** String
A string is a wrapper around a raw =char= pointer and a size. This is used
as the base string literal.

#+NAME: worgle_string
#+BEGIN_SRC c
typedef struct {
    char *str;
    size_t size;
} worgle_string;
#+END_SRC
*** Reset or initialize a string
*** Writing a String
** Segment

A segment turns a string into a linked list component that has a type.
A segment type flag can either be a text chunk or a reference.

#+NAME: worgle_segment
#+BEGIN_SRC c
enum {
<<worgle_segment_types>>
};
typedef struct worgle_segment {
    int type;
    worgle_string str;
    <<worgle_segment_line_control>>
    struct worgle_segment *nxt;
} worgle_segment;
#+END_SRC

Segments also keep track of where they are in the original org file.
This information can be used to generate line control preprocessor commands
for C/C++.

#+NAME: worgle_segment_line_control
#+BEGIN_SRC c
size_t linum;
worgle_string *filename;
#+END_SRC
*** Text Chunk Type

A text chunk is a literal string of text.

When a text chunk segment is processed, it gets written to file directly.

#+NAME: worgle_segment_types
#+BEGIN_SRC c
SEGTYPE_TEXT,
#+END_SRC
*** Reference Type

A reference contains a string reference to another block.

When a reference
segment gets processed, it looks up the reference and processes all the
segements in that code block.

#+NAME: worgle_segment_types
#+BEGIN_SRC c
SEGTYPE_REFERENCE
#+END_SRC
*** Writing a Segment
** Code Block
A code block is a top-level unit that stores some amount of code. It is
made up of a list of segments. Every code block has a unique name.

#+NAME: worgle_block
#+BEGIN_SRC c
typedef struct worgle_block {
    int nsegs;
    worgle_segment *head;
    worgle_segment *tail;
    worgle_string name;
    struct worgle_block *nxt;
} worgle_block;
#+END_SRC
*** Appending a segment to a code block
*** Appending a codeblock to a code block

In both CWEB and Org-tangle, code blocks can be appeneded to in
different sections. To do this,
one must simply continue to append segments to the already existing block.
This is all that is needed for the tangler, but more sophistication
may be needed for the weaving code into human-readable documents.
*** Writing a codeblock to filehandle

This is done by going through the list in the code block and writing all
the segments.
** Code Block List

A code block list is a linked list of blocks, which is used inside of a
hash map.
#+NAME: worgle_blocklist
#+BEGIN_SRC c
typedef struct {
    int nblocks;
    worgle_block *head;
    worgle_block *tail;
} worgle_blocklist;
#+END_SRC
*** Block List Initialization
*** Freeing a Block List
*** Appending a Block
** Hash Map

A hash map is a key-value data structure used as a dictionary for storing
references to code blocks.
#+NAME: worgle_hashmap
#+BEGIN_SRC c
typedef struct {
    worgle_blocklist blk[256];
    int nwords;
} worgle_hashmap;
#+END_SRC
*** Hash map Initialization

*** Freeing a Hash Map

*** Getting an entry

To "get" an entry means to return a block if it exists or not. Return
an entry that exists, or make a new one.
*** Looking up an entry
** File
An orgle file is an abstraction for a single file orgle can write to. Every
file has a filename, and a top-level code block.
#+NAME: worgle_file
#+BEGIN_SRC c
typedef struct worgle_file {
    worgle_string filename;
    worgle_block *top;
    struct worgle_file *nxt;
} worgle_file;
#+END_SRC
*** Initializing an orgle file
*** Writing A File to Disk
This will actually open a filehandle, and write the top-level code block to
disk.
** The File List

A file list is a linked list of files.
#+NAME: worgle_filelist
#+BEGIN_SRC c
typedef struct {
    worgle_file *head;
    worgle_file *tail;
    int nfiles;
} worgle_filelist;
#+END_SRC
*** Initializing a file list

*** Freeing a file list

*** Appending a file to a file list
